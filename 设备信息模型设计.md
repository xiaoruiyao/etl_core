这份结构现在已经非常成熟了，涵盖了从**宏观结果**到**微观过程**，再到**工艺标准**与**原始数据（曲线）**的全维度追溯体系。

为了让这套设计在实际生产环境中更加稳健，我最后为你做了一次**一致性对齐**（特别是 `program` 关联部分）和**关键字段的微调**。

---

## 最终优化版架构图

---

## 最终版 DDL 汇总

### 1. 工艺程序标准表 (`program`)

**优化点：** 作为基础字典表，它是追溯的源头。

```sql
CREATE TABLE "biz"."program" (
  "id" bigserial PRIMARY KEY,
  "program_id" varchar(64) NOT NULL,    -- 程序编号
  "version" varchar(16) NOT NULL,       -- 版本号
  "program_name" varchar(128),
  "craft_type" varchar(64),             -- 工艺类型: TIGHTENING, PRESS, WELDING, GLUING
  "device_type" varchar(64),            -- 设备类型/型号
  "target_value" numeric(10,2),
  "upper_limit" numeric(10,2),
  "lower_limit" numeric(10,2),
  "is_active" bool DEFAULT true,
  "create_time" timestamp(6) DEFAULT CURRENT_TIMESTAMP,
  UNIQUE("program_id", "version")       -- 保证程序号+版本的唯一性
);
```

### 2. 生产结果主表 (`result`)

**优化点：** 改名为 `result`，保持简洁。显式通过 `program_ver_id` 关联具体版本的程序。

```sql
CREATE TABLE "biz"."result" (
  "id" bigserial,
  "cyclenumber" varchar(64),
  "device_name" varchar(64),
  "craft_type" varchar(64),             -- 冗余字段，便于不关联查询直接统计
  "system_id" varchar(64) NOT NULL,     -- 逻辑系统/工位 ID
  "bsn" varchar(64),                    -- 零件条码 / 序列号
  "vin" varchar(64),                    -- 车辆识别代码
  "program_id" varchar(64),             -- 外键引用字符串 (冗余)
  "program_ver_id" int8,                -- 关联 program.id
  "result_status" int2 NOT NULL,        -- 1:OK, 0:NOK, 2:Warn
  "status_code" varchar(32),            -- 具体的错误代码 (如有)
  "start_time" timestamp(6) NOT NULL,
  "end_time" timestamp(6) NOT NULL,
  "cycle_time" numeric(10,3),           -- 周期时长 (秒)
  "key_value" numeric(10,2),            -- 关键 KPI (如 最终扭矩, 最大压力)
  "create_time" timestamp(6) DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY ("id", "start_time")      -- 分区表必须包含分区键作为主键的一部分
) PARTITION BY RANGE (start_time);

CREATE INDEX idx_result_bsn ON "biz"."result" ("bsn", "start_time");
CREATE INDEX idx_result_vin ON "biz"."result" ("vin", "start_time");
```

### 3. 过程与明细表 (`step`, `alarm`)

**优化点：** 建立清晰的父子关系索引，确保查询步骤和报警时的秒开体验。

```sql
-- 步骤表
CREATE TABLE "biz"."step" (
  "id" bigserial PRIMARY KEY,
  "result_id" int8 NOT NULL,
  "step_index" int4 NOT NULL,
  "step_name" varchar(64),
  "step_result" int2,
  "step_value" numeric(10,2),
  "target_value" numeric(10,2),
  "start_time" timestamp(6),
  "end_time" timestamp(6)
);
CREATE INDEX idx_step_result_id ON "biz"."step" ("result_id");

-- 报警表
CREATE TABLE "biz"."alarm" (
  "id" bigserial PRIMARY KEY,
  "result_id" int8 NOT NULL,
  "step_id" int8,                       -- 关键：定位到具体步骤
  "alarm_code" varchar(64),
  "alarm_level" varchar(16),
  "alarm_msg" text,
  "parent_alarm_id" int8 REFERENCES "biz"."alarm"("id"), -- 父级报警ID
  "create_time" timestamp(6) DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX idx_alarm_result_id ON "biz"."alarm" ("result_id");
CREATE INDEX idx_alarm_step_id ON "biz"."alarm" ("step_id");
CREATE INDEX idx_alarm_parent_id ON "biz"."alarm" ("parent_alarm_id");
```

### 4. 数据扩展表 (`curve`, `extension`)

```sql
-- 曲线数据
CREATE TABLE "biz"."curve" (
  "id" bigserial PRIMARY KEY,
  "result_id" int8,                     -- 移除 UNIQUE，支持多步多行
  "step" int4,                          -- 步骤号
  "start_time" timestamp(6),
  "end_time" timestamp(6),
  "curve_type" varchar(32),
  "data_points" jsonb,
  "storage_path" varchar(255),
  "sample_rate" int4
);

-- 业务扩展
CREATE TABLE "biz"."extension" (
  "result_id" int8 PRIMARY KEY,
  "extra_data" jsonb,
  "operator_id" varchar(64),
  "fixture_id" varchar(64)
);
CREATE INDEX idx_extension_data ON "biz"."extension" USING GIN (extra_data);
```

---

## 🛠 落地实战建议

1. **关于分区表 (Partitioning)**：
    - 在 PostgreSQL 中，如果使用按时间分区，记得提前创建分区子表（如 `process_result_2024_m01`），或者使用插件如 `pg_partman` 自动管理。
2. **关于 `JSONB` 查询**：
    - 如果你经常需要查询 `extra_data` 里的某个特定字段（比如 `humidity`），可以创建 GIN 索引：
        
        `CREATE INDEX idx_extension_data ON "biz"."extension" USING GIN (extra_data);`
        
3. **关于性能**：
    - 主表 `result` 尽量不存储大文本，保持每一行物理长度相近，有利于高频插入时的 IO 稳定。

---

## 🌍 数据映射实例分析 (Origin -> Biz)

基于 `origin.bs_fds_v_fds_curves` 视图中的实际数据样本 `autoindex=251067`，我们制定以下字段映射策略：

### 样本数据 (autoindex=251067)
- **autoindex**: 251067
- **actualprogramid**: 68500
- **systemid**: MB240RB06
- **startselection**: 10
- **ok_nok_code**: 1
- **lastexecutedstep**: 3
- **starttime**: 2025-09-08T01:50:55
- **cyclenumber**: 32980
- **duration**: 1.43801
- **bsn**: 30S028741
- **progselection**: 10
- **curve**: (Binary Blob)

### 映射对应关系

#### 1. biz.result (主结果表)
| Biz Field | Origin / Logic | Example Value | Description |
| :--- | :--- | :--- | :--- |
| **id** | `bs_fds_results.autoindex` | `251067` | - |
| **cyclenumber** | `bs_fds_results.cyclenumber` | `32980` | - |
| **device_name** | `bs_fds_results.systemid` | `MB240RB06` | - |
| **program_id** | `bs_fds_results.actualprogramid` | `68500` | - |
| **program_ver_id** | `bs_fds_results.actualprogramid` | `68500` | 暂用 ID 关联 |

#### 2. biz.program (工艺程序表)
数据来源于 `bs_fds_progtable` (关联键 `autoprogindex` = `result.actualprogramid`)
| Biz Field | Origin / Logic | Example Value | Description |
| :--- | :--- | :--- | :--- |
| **id** | `autoprogindex` | `68500` | - |
| **program_id** | `startstring` (trimmed) | `10` | 程序号 |
| **program_name** | `name` (trimmed) | `09121-0522F70_I0025` | 程序名称 |
| **version** | `lastchangedatetime` | `2025-08-20...` | 使用最后修改时间作为版本标识 |

#### 3. biz.step (步骤表)
混合来源：主要步骤仍来自曲线解析（因为能还原时序），但关键 KPI 值可从 `bs_fds_singleresult` 补充。
- **step_value**: 尝试匹配 `bs_fds_singleresult` 中对应 `step` 的 `value`。
    - 例: `step=3` 有两条记录 (type=7 value=0.007, type=2 value=6.30432)。
    - 需进一步推断 `type` 含义 (可能 2=Torque, 7=Angle?)。暂将所有 single result 存入 json 或 `extension`。

#### 4. biz.curve (曲线表)
| Biz Field | Origin / Logic | Example Value | Description |
| :--- | :--- | :--- | :--- |
| **result_id** | `autoindex` | `251067` | 关联主表 |
| **step** | `step` parsed | `1` | 按步骤拆分 |
| **curve_type** | Derived | `TORQUE`, `SPEED`, `ANGLE`, `DEPTH` | **变更**: 每步拆分为多条单一物理量曲线 (X=Time) |
| **start_time** | Calc | `2025-09-08...` | 曲线段开始时间 |
| **end_time** | Calc | `2025-09-08...` | 曲线段结束时间 |
| **data_points** | Parse(`curve`) | `{"x":[], "y":[]}` | 存为 X/Y 数组格式 |

- **curve_type 轴定义**:
    | Type | X-Axis | Y-Axis | Description |
    | :--- | :--- | :--- | :--- |
    | `TORQUE` | Time (s) | Torque (Nm) | 扭矩随时间变化 |
    | `SPEED` | Time (s) | Speed (rpm) | 转速随时间变化 |
    | `ANGLE` | Time (s) | Angle (deg) | 角度随时间变化 |
    | `DEPTH` | Time (s) | Depth (mm) | 深度/位移随时间变化 |
    | `PRESSURE` | Time (s) | Pressure (bar) | 压力随时间变化 |
    | `TORQUE_ANGLE` | Angle (deg) | Torque (Nm) | 扭矩随角度变化 (XY图) |

#### 5. biz.extension (扩展表)
- 增加 `single_results` 字段存储 `bs_fds_singleresult` 的完整列表，防止 KPI 丢失。

#### 4. biz.extension (扩展表)
| Biz Field | Origin / Logic | Example Value | Description |
| :--- | :--- | :--- | :--- |
| **result_id** | `autoindex` | `251067` | - |
| **extra_data** | JSON Construct | `{"startselection": 10, "progselection": 10, "lastexecutedstep": 3}` | 存储非标准字段 |

#### 5. biz.alarm (报警表)
- **Source**: 当前视图 `bs_fds_v_fds_curves` 无直接报警字段。
- **Logic**: 如果 `ok_nok_code` 指示错误，可在 Alarm 表生成一条通用报警，记录 `lastexecutedstep` 和 `ok_nok_code`。

---

## 🔩 SPR (Self-Piercing Rivet) 工艺数据映射

### 数据源表
- **origin.bs_spr_detail**: 结果详情表（主表）
- **origin.bs_spr_graph**: 曲线数据表（通过 `id` 字段与 detail 关联）

### 样本数据 (id=583435)
| 字段 | 值 |
|-----|-----|
| id | 583435 |
| device_name | HD005R02-SPR |
| result_sequence_number | 55996 (循环编号) |
| result_date_time | 2025-09-18 18:13:16 |
| program_identifier | 122-1.10.ARRS01HD0068 |
| p_name | ARRS01HD0068 |
| program_version | 2 |
| final_force | 28.3 (关键KPI) |
| final_stroke | -0.52 |
| limit_high | 34.4 |
| limit_low | 24.2 |
| cycle_time | 0.045s |

### 字段映射

#### biz.result
| Biz 字段 | Origin 来源 |
|---------|------------|
| id | bs_spr_detail.id |
| cyclenumber | bs_spr_detail.result_sequence_number |
| device_name | bs_spr_detail.device_name |
| craft_type | `SPR` (固定值) |
| result_status | 根据 short_description 判断 (OK=1, NOK=0) |
| key_value | bs_spr_detail.final_force |
| cycle_time | bs_spr_detail.cycle_time |

#### biz.curve
SPR 每个结果有 2 条曲线记录：
| curve_type | 说明 | X轴 | Y轴 |
|-----------|------|-----|-----|
| FORCE | 力随时间变化 | Time (s) | Force (N) |
| STROKE | 行程随时间变化 | Time (s) | Stroke (mm) |

- 曲线数据格式: **gzip 压缩的 float32 数组**
- 每条曲线约 50 个数据点

#### biz.extension
存储 SPR 特有的扩展参数：
```json
{
  "final_force": 28.3,
  "final_stroke": -0.52,
  "start_distance": 6.89,
  "end_distance": 6.37,
  "velocity": 180.0,
  "limit_high": 34.4,
  "limit_low": 24.2,
  "parameter_type": "Final Force"
}
```

### ETL 脚本
- **etl_spr_migration.py**: SPR 工艺专用迁移脚本
- 使用方式:
  ```bash
  # 单条测试
  python etl_spr_migration.py --single-id 583435
  
  # 批量迁移
  python etl_spr_migration.py --batch --limit 1000
  ```

---


---

## 🏭 设备层级与点位设计 (Device Hierarchy & Points)

针对 "工厂 -> 车间 -> 产线 -> 工位 (Station) -> 设备 (Device)" 的主要物理层级，以及涉及 PLC 控制逻辑和时序点位 (`device_url`) 的复杂需求，我们设计如下双层结构方案。

此方案完美解决了 **"物理归属"** 与 **"控制逻辑"** (PLC包含设备) 的矛盾，并为点位查询提供了统一入口。

### 1. 核心结构表 (`biz.structure`) - 物理视图为主

这张表统一存储所有的层级节点，以**物理位置**为骨架构建树状结构。

```sql
CREATE TABLE "biz"."structure" (
  "id" bigserial PRIMARY KEY,
  "name" varchar(128) NOT NULL,
  "level_type" varchar(32) NOT NULL,    -- FACTORY, WORKSHOP, LINE, STATION, DEVICE, PLC
  "parent_id" int8,                     -- 物理归属父节点 (Factory->Workshop->Line->Station)
  "path" varchar(255) NOT NULL,         -- Materialized Path: /1/5/12/
  "device_name" varchar(64),            -- 关联业务ID (对应 result.device_name, device_uri.device_id)
  "attributes" jsonb,                   -- 核心设计的灵活性所在 (存放 plc_id 等)
  "create_time" timestamp(6) DEFAULT CURRENT_TIMESTAMP
);
-- Indexes
CREATE INDEX idx_structure_path ON "biz"."structure" ("path" varchar_pattern_ops);
CREATE INDEX idx_structure_device ON "biz"."structure" ("device_name");
```

### 2. 解决 "PLC与工位同级但又包含设备" 的矛盾

我们通过 **"物理挂载 + 逻辑关联"** 的方式，在一棵树上支持两种视图：

*   **物理层级 (Physical View)**:
    *   **Station (工位)**: 隶属于 Line (parent_id = Line_ID)。
    *   **Device (设备)**: 隶属于 Station (parent_id = Station_ID)。
    *   **PLC (控制器)**: 隶属于 Line 或 Station (视物理安装位置而定，通常作为资产节点存在)。

*   **逻辑控制 (Logical Control View)**:
    *   在 **Device** 节点的 `attributes` 字段中记录 `plc_id` (指向 structure 表中的 PLC 节点 ID)。
    *   **PLC "包含" 设备**: 实际上是通过属性关联的。
    *   **查询 API**:
        *   *查工位下的设备*: `WHERE parent_id = {station_id}`
        *   *查PLC控制的设备*: `WHERE attributes->>'plc_id' = {plc_id}`

### 3. 点位信息表 (`biz.device_uri` / `biz.point`)

现有的 `device_uri` 表承载了点位定义。为了支持通过层级筛选点位，以及**支持点位分组（文件夹嵌套）**，我们对其进行**语义增强**。

**建议表结构优化:**
```sql
CREATE TABLE "biz"."point" (
  "id" bigserial PRIMARY KEY,
  "structure_id" int8 REFERENCES "biz"."structure"("id"), -- 关联设备/PLC节点
  "device_id" varchar(64),          -- 冗余原有ID
  "point_name" varchar(128),        -- 显示名称 "安全输出起始地址"
  "point_uri" varchar(255),         -- 采集地址
  "group_path" varchar(255),        -- [新增] 分组路径: "Fanuc机器人参数集/PLC源数据/标准IO"
  "data_type" varchar(32),          -- 数据类型
  "is_ts" bool DEFAULT true         -- 是否为时序数据
);
-- Indexes
CREATE INDEX idx_point_structure ON "biz"."point" ("structure_id");
```

**设计要点 - 分组实现 (`group_path`):**
*   **需求**: 如截图中 `Fanuc机器人参数集 -> PLC源数据 -> 标准IO -> 点位` 的多层文件夹。
*   **方案**: 使用 `group_path` 字段存储类似文件系统的路径。
    *   Point A: `group_path = "Fanuc机器人参数集/PLC源数据/标准IO"`
*   **前端渲染**:
    1.  获取某设备下的所有 Point。
    2.  解析 `group_path`，动态构建文件夹树形结构。
*   **优势**: 避免了在 `biz.structure` 资产树中创建大量非实体的"文件夹节点"，保持资产树纯净。

**前端筛选设计:**

1.  **左侧**: 展示 `biz.structure` 树形 (物理结构)。
2.  **中间 (点位列表)**:
    *   **点击 Station**: 展示该 Station 下所有 Device 的点位。
        *   SQL: `SELECT * FROM point WHERE structure_id IN (SELECT id FROM structure WHERE path LIKE '/.../station_id/%')`
    *   **点击 PLC**: 展示该 PLC 自身的点位 + 它控制的 Device 的点位。
        *   SQL: `SELECT * FROM point WHERE structure_id = {plc_id} OR structure_id IN (SELECT id FROM structure WHERE attributes->>'plc_id' = {plc_id})`

这种设计既满足了 "设备属于工位" 的物理事实，又满足了 "PLC控制设备" 的数据查询需求。


